import subprocess
import edk_sar as es
import glob
import os
from osgeo import gdal
from edk_sar.workflows.base import helpers

# ----------------------------
# Helper functions to run interferogram workflows
# ----------------------------

def generate_run_files():
    run_files_cmd = [
        "bash",
        "/workspace/workflows/interferograms/generate_run_files.sh",
    ]
    es.frameworks.isce2.run_cmd(" ".join(run_files_cmd))


def execute_run_files():
    es.workflows.isce2.run_cmd(
        "bash /workspace/workflows/interferograms/execute_run_files.sh"
    )


# ----------------------------
# Functions to compute derived products from interferograms
# ----------------------------

def compute_phase(int_vrt_path: str, phase_vrt_path: str):
    """
    Create a Phase VRT from a wrapped interferogram (.int.vrt).

    Parameters:
    - int_vrt_path : str : Path to wrapped interferogram VRT.
    - phase_vrt_path : str : Path to save the generated phase VRT.
    """
    # Open input VRT to get raster dimensions
    ds = gdal.Open(int_vrt_path)
    if ds is None:
        raise FileNotFoundError(f"Cannot open input VRT: {int_vrt_path}")
    xsize = ds.RasterXSize
    ysize = ds.RasterYSize
    ds = None

    # Create VRT content with pixel function type "phase"
    vrt_content = f"""
 <VRTDataset rasterXSize="{xsize}" rasterYSize="{ysize}">
    <VRTRasterBand dataType="Float32" band="1" subClass="VRTDerivedRasterBand">
        <PixelFunctionType>phase</PixelFunctionType>
        <SourceTransferType>CFloat32</SourceTransferType>
        <SimpleSource>
            <SourceFilename relativeToVRT="1">{int_vrt_path}</SourceFilename>
            <SourceBand>1</SourceBand>
        </SimpleSource>
    </VRTRasterBand>
 </VRTDataset>
 """
    # Save the new Phase VRT
    with open(phase_vrt_path, "w") as f:
        f.write(vrt_content)

    print(f"[OK] Phase VRT created: {phase_vrt_path}")

def compute_displacement(unwrap_vrt_path: str, displacement_tif_path: str, wavelength_m: float):
    """
    Compute displacement from an unwrapped interferogram.

    Parameters:
    - unwrap_vrt_path : str : Input unwrapped interferogram VRT
    - displacement_tif_path : str : Path to save displacement (GeoTIFF)
    - wavelength_m : float : Radar wavelength in meters
    """
    if not os.path.exists(unwrap_vrt_path):
        raise FileNotFoundError(f"Input unwrapped VRT not found: {unwrap_vrt_path}")

    # we will Use GeoTIFF output, not VRT
    # we need to change the output file from a .vrt to a real raster format, typically GeoTIFF (.tif).
    # because gdal_calc.py cannot write to a VRT because it's just a virtual dataset.
    # I have again added a step below to create a VRT from the GeoTIFF for geocoding later.
    cmd = [
        "gdal_calc.py",
        "-A", unwrap_vrt_path, "--A_band=1",
        "--outfile", displacement_tif_path,
        "--calc", f"({wavelength_m}/(4*3.14159265359))*A",
        "--type", "Float32"
    ]

    subprocess.run(cmd, check=True)
    print(f"[OK] Displacement computed: {displacement_tif_path}")

# ----------------------------
# Main runner function
# ----------------------------

def run(slc_path, base_dir, wavelength_m: float):
    """
    Main function to process SLCs, generate interferogram products, 
    and geocode outputs.

    Parameters:
    - slc_path : str : Path containing input SLC zip files.
    - base_dir : str : Base directory where interferogram and geom_reference folders exist.
    - wavelength_m : float : Radar wavelength in meters (lambda).
    
    Returns:
    - geocoded_paths : dict : Dictionary of geocoded outputs.
    """
    # Prepare SLC processing environment
    es.workflows.base.create_netrc()
    es.workflows.base.create_folders()
    es.workflows.base.copy_slcs(slc_path)
    es.workflows.base.get_aux_file()
    
    # Get bounding box of SLCs and download DEM
    slcs = glob.glob(os.path.join(slc_path, "*.zip"))
    common_bbox = helpers.get_common_bbox(slcs)
    es.workflows.base.download_dem(common_bbox)
    

    # ----------------------------
    # Define geometrical references
    # ----------------------------
    lon_rdr = os.path.join(base_dir, "geom_reference", "lon.rdr.full.vrt")
    lat_rdr = os.path.join(base_dir, "geom_reference", "lat.rdr.full.vrt")

    # ----------------------------
    # Define interferogram directory and input/output files
    # ----------------------------
    interferogram_dir = os.path.join(base_dir, "interferograms", "20180830_20181228")
    
    # Input files
    wrapped_vrt = os.path.join(interferogram_dir, "filt_fine.int.vrt")
    unwrapped_vrt = os.path.join(interferogram_dir, "filt_fine.unw.vrt")
    coherence_vrt = os.path.join(interferogram_dir, "filt_fine.cor.vrt")
    connected_component_vrt = os.path.join(interferogram_dir, "filt_fine.conncomp.vrt")

    # Outputs generated by us
    phase_vrt = os.path.join(interferogram_dir, "phase.vrt")
    displacement_vrt = os.path.join(interferogram_dir, "displacement.vrt")

    # ----------------------------
    # Run interferogram processing scripts
    # ----------------------------
    generate_run_files()
    execute_run_files()

    # ----------------------------
    # Compute derived products
    # ----------------------------
    compute_phase(wrapped_vrt, phase_vrt)
    displacement_tif = os.path.join(interferogram_dir, "displacement.tif")
    compute_displacement(unwrapped_vrt, displacement_tif, wavelength_m)

    # creating a VRT for geocoding
    displacement_vrt = os.path.join(interferogram_dir, "displacement.vrt")
    subprocess.run([
        "gdal_translate",
        "-of", "VRT",
        displacement_tif,
        displacement_vrt
    ], check=True)


    # ----------------------------
    # Geocode all relevant files
    # ----------------------------
    files_to_geocode = [
        ("phase.vrt", phase_vrt),
        ("displacement.vrt", displacement_vrt),
        ("wrapped_vrt", wrapped_vrt),
        ("unwrapped_vrt", unwrapped_vrt),
        ("coherence.vrt", coherence_vrt),
        ("connected_component.vrt", connected_component_vrt)
    ]

    geocoded_paths = {}

    for name, file_path in files_to_geocode:
        if os.path.exists(file_path):
            geocoded_path = os.path.join(interferogram_dir, f"{name}_geocoded.vrt")
            helpers.geocode(file_path, lon_rdr, lat_rdr, geocoded_path)
            geocoded_paths[name] = geocoded_path
        else:
            print(f"[SKIP] File not found, skipping geocode: {file_path}")

    # Return dictionary of geocoded paths for downstream use
    return geocoded_paths
