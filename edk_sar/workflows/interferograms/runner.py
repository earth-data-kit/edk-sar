import subprocess
import edk_sar as es
import glob
import os
from osgeo import gdal
from edk_sar.workflows.base import helpers
import numpy as np
from edk_sar.workflows.base.constants import SENTINEL_WAVELENGTH, PI

# ----------------------------
# Helper functions to run interferogram workflows
# ----------------------------

def generate_run_files():
    run_files_cmd = [
        "bash",
        "/workspace/workflows/interferograms/generate_run_files.sh",
    ]
    es.frameworks.isce2.run_cmd(" ".join(run_files_cmd))


def execute_run_files():
    es.frameworks.isce2.run_cmd(
        "bash /workspace/workflows/interferograms/execute_run_files.sh"
    )


# ----------------------------
# Functions to compute derived products from interferograms
# ----------------------------

def compute_phase(int_vrt_path: str, phase_vrt_path: str):
    """
    Create a Phase VRT from a wrapped interferogram (.int.vrt).

    Parameters:
    - int_vrt_path : str : Path to wrapped interferogram VRT.
    - phase_vrt_path : str : Path to save the generated phase VRT.
    """
    # Open input VRT to get raster dimensions
    ds = gdal.Open(int_vrt_path)
    if ds is None:
        raise FileNotFoundError(f"Cannot open input VRT: {int_vrt_path}")
    xsize = ds.RasterXSize
    ysize = ds.RasterYSize
    ds = None

    # Create VRT content with pixel function type "phase"
    vrt_content = f"""
 <VRTDataset rasterXSize="{xsize}" rasterYSize="{ysize}">
    <VRTRasterBand dataType="Float32" band="1" subClass="VRTDerivedRasterBand">
        <PixelFunctionType>phase</PixelFunctionType>
        <SourceTransferType>CFloat32</SourceTransferType>
        <SimpleSource>
            <SourceFilename relativeToVRT="1">{int_vrt_path}</SourceFilename>
            <SourceBand>1</SourceBand>
        </SimpleSource>
    </VRTRasterBand>
 </VRTDataset>
 """
    # Save the new Phase VRT
    with open(phase_vrt_path, "w") as f:
        f.write(vrt_content)

    print(f"[OK] Phase VRT created: {phase_vrt_path}")

def compute_displacement(unwrapped_vrt_path: str, displacement_vrt_path: str):
    """
    Compute displacement from an unwrapped interferogram (in radians)
    and save as GeoTIFF + VRT wrapper using gdal_calc.py.
    """
    # Output GeoTIFF path (same folder as displacement_vrt)
    displacement_tif = displacement_vrt_path.replace(".vrt", ".tif")

    subprocess.run([
        "gdal_calc.py",
        "-A", unwrapped_vrt_path,
        "--outfile", displacement_tif,
        "--calc", f"(A*{SENTINEL_WAVELENGTH})/({PI}*4)",
        "--type", "Float32",
        "--overwrite"
    ], check=True)
    print(f"[OK] Displacement GeoTIFF created: {displacement_tif}")

    # Wrap as VRT
    subprocess.run([
        "gdal_translate",
        "-of", "VRT",
        displacement_tif,
        displacement_vrt_path
    ], check=True)
    print(f"[OK] Displacement VRT created: {displacement_vrt_path}")

# ----------------------------
# Main runner function
# ----------------------------

def run(slc_path, base_dir):
    """
    Main function to process SLCs, generate interferogram products, 
    and geocode outputs.
    
    Parameters:
    - slc_path : str : Path containing input SLC zip files.
    - base_dir : str : Base directory where interferogram and geom_reference folders exist.
    
    Returns:
    - geocoded_paths : dict : Dictionary of geocoded outputs.
    """
    # Prepare SLC processing environment
    es.workflows.base.create_netrc()
    es.workflows.base.create_folders()
    es.workflows.base.copy_slcs(slc_path)
    es.workflows.base.get_aux_file()

    # ----------------------------
    # Run interferogram processing scripts
    # ----------------------------

    # Get bounding box of SLCs and download DEM
    slcs = glob.glob(os.path.join(slc_path, "*.zip"))
    common_bbox = helpers.get_common_bbox(slcs)
    es.workflows.base.download_dem(common_bbox)

    generate_run_files()
    execute_run_files()



    # Inside Docker container
    # Define geometrical references
    lon_rdr = os.path.join(base_dir, "geom_reference", "lon.rdr.vrt")
    lat_rdr = os.path.join(base_dir, "geom_reference", "lat.rdr.vrt")


    # Define interferogram directory and input/output files
    interferograms_root = os.path.join(base_dir, "interferograms")
    interferogram_dirs = [d for d in glob.glob(os.path.join(interferograms_root, "*")) if os.path.isdir(d)]

    if not interferogram_dirs:
        raise FileNotFoundError("No interferogram directories found!")

    # Pick the first one
    interferogram_dir = interferogram_dirs[0]

    # Input files
    wrapped_vrt = os.path.join(interferogram_dir, "filt_fine.int.vrt")
    unwrapped_vrt = os.path.join(interferogram_dir, "filt_fine.unw.vrt")
    coherence_vrt = os.path.join(interferogram_dir, "filt_fine.cor.vrt")
    connected_component_vrt = os.path.join(interferogram_dir, "filt_fine.unw.conncomp.vrt")

    # Outputs generated by us
    phase_vrt = os.path.join(interferogram_dir, "phase.vrt")
    displacement_vrt = os.path.join(interferogram_dir, "displacement.vrt")


    # ----------------------------
    # Compute derived products
    # ----------------------------
    compute_phase(wrapped_vrt, phase_vrt)
    compute_displacement(unwrapped_vrt, displacement_vrt)

    # ----------------------------
    # Geocode all relevant files
    # ----------------------------
    files_to_geocode = [
        ("phase.vrt", phase_vrt),
        ("displacement.vrt", displacement_vrt),
        ("wrapped_vrt", wrapped_vrt),
        ("unwrapped_vrt", unwrapped_vrt),
        ("coherence.vrt", coherence_vrt),
        ("connected_component.vrt", connected_component_vrt)
    ]

    geocoded_paths = {}

    for name, file_path in files_to_geocode:
        if os.path.exists(file_path):
            geocoded_path = os.path.join(interferogram_dir, f"{name}_geocoded.vrt")
            helpers.geocode(file_path, lon_rdr, lat_rdr, geocoded_path)
            geocoded_paths[name] = geocoded_path
        else:
            print(f"[SKIP] File not found, skipping geocode: {file_path}")

    # Return dictionary of geocoded paths for downstream use
    return geocoded_paths
    